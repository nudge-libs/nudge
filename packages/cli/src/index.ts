import type { BaseStep, PromptTest } from "@nudge-ai/core/internal";
import "dotenv/config";
import * as fs from "fs";
import { processPrompt, type AIConfig } from "./ai.js";
import { hashState, loadExistingPrompts } from "./cache.js";
import { discoverPrompts, type DiscoveredPrompt } from "./discover.js";
import {
  evaluateVariant,
  formatEvaluationSummary,
  formatVariantEvaluation,
  type VariantEvaluation,
} from "./eval.js";
import { improve, type ImproveOptions, type ImprovementResult } from "./improve.js";

export type GenerateOptions = {
  promptFilenamePattern?: string;
  aiConfig?: AIConfig;
  noCache?: boolean;
};

function escapeForTemplateLiteral(text: string): string {
  return text
    .replace(/\\/g, "\\\\")
    .replace(/`/g, "\\`")
    .replace(/\$\{/g, "\\${");
}

function extractVariables(variants: Record<string, string>): string[] {
  const allVars = new Set<string>();
  for (const text of Object.values(variants)) {
    for (const match of text.matchAll(/\{\{(?![#\/])(\w+)\}\}/g)) {
      allVars.add(match[1]);
    }
  }
  return [...allVars];
}

async function generate(
  targetDir: string,
  outputPath: string,
  options: GenerateOptions = {},
) {
  const pattern = options.promptFilenamePattern ?? "**/*.prompt.{ts,js}";
  const prompts = await discoverPrompts(targetDir, pattern);

  if (!options.aiConfig) {
    throw new Error("AI config is required in nudge.config.json");
  }

  const existingPrompts = loadExistingPrompts(outputPath);

  console.log(`Processing ${prompts.length} prompt(s)...`);

  const results = await Promise.all(
    prompts.map(async (prompt) => {
      const hash = hashState(prompt.state);
      const existing = existingPrompts[prompt.id];

      let variants: Record<string, string>;

      if (!options.noCache && existing && existing.hash === hash) {
        console.log(`  ✓ "${prompt.id}" unchanged (cached)`);
        variants = existing.variants as Record<string, string>;
      } else {
        const definedVariants = prompt.state.variants ?? [];

        if (definedVariants.length === 0) {
          // No variants defined - generate single "default" prompt
          console.log(`  → "${prompt.id}" processing with AI...`);
          const text = await processPrompt(
            prompt.state.steps,
            options.aiConfig!,
          );
          variants = { default: text };
        } else {
          // Generate one prompt per variant (base steps + variant steps)
          console.log(
            `  → "${prompt.id}" generating ${definedVariants.length} variant(s)...`,
          );
          const variantEntries = await Promise.all(
            definedVariants.map(async (v) => {
              const combinedSteps: BaseStep[] = [
                ...prompt.state.steps,
                ...v.steps,
              ];
              const text = await processPrompt(
                combinedSteps,
                options.aiConfig!,
              );
              return [v.name, text] as const;
            }),
          );
          variants = Object.fromEntries(variantEntries);
        }
      }

      const variables = extractVariables(variants);

      const variantNames = Object.keys(variants).filter((k) => k !== "default");

      const variantEntries = Object.entries(variants)
        .map(([name, text]) => {
          const escaped = escapeForTemplateLiteral(text);
          return `      ${JSON.stringify(name)}: \`${escaped}\``;
        })
        .join(",\n");

      return {
        id: prompt.id,
        entry: `  ${JSON.stringify(prompt.id)}: {\n    variants: {\n${variantEntries},\n    },\n    hash: ${JSON.stringify(hash)},\n  }`,
        registry: `    ${JSON.stringify(prompt.id)}: true;`,
        variables:
          variables.length > 0
            ? `    ${JSON.stringify(prompt.id)}: ${variables.map((v) => JSON.stringify(v)).join(" | ")};`
            : null,
        variantNames:
          variantNames.length > 0
            ? `    ${JSON.stringify(prompt.id)}: ${variantNames.map((v) => JSON.stringify(v)).join(" | ")};`
            : null,
      };
    }),
  );

  const promptEntries = results.map((r) => r.entry);
  const registryEntries = results.map((r) => r.registry);
  const variableEntries = results
    .map((r) => r.variables)
    .filter((v): v is string => v !== null);
  const variantEntries = results
    .map((r) => r.variantNames)
    .filter((v): v is string => v !== null);

  const variablesInterface =
    variableEntries.length > 0
      ? `\n  interface PromptVariables {\n${variableEntries.join("\n")}\n  }`
      : "";

  const variantsInterface =
    variantEntries.length > 0
      ? `\n  interface PromptVariants {\n${variantEntries.join("\n")}\n  }`
      : "";

  const code = `// This file is auto-generated by @nudge-ai/cli. Do not edit manually.
import { registerPrompts } from "@nudge-ai/core";

declare module "@nudge-ai/core" {
  interface PromptRegistry {
${registryEntries.join("\n")}
  }${variablesInterface}${variantsInterface}
}

const prompts = {
${promptEntries.join(",\n")}
} as const;

registerPrompts(prompts);
`;

  // Write TypeScript file
  fs.writeFileSync(outputPath, code, "utf-8");
  console.log(`Generated ${outputPath} with ${prompts.length} prompt(s)`);
}

export type EvaluateOptions = {
  promptFilenamePattern?: string;
  aiConfig?: AIConfig;
  verbose?: boolean;
  judge?: boolean;
};

async function evaluate(
  targetDir: string,
  outputPath: string,
  options: EvaluateOptions = {},
): Promise<VariantEvaluation[]> {
  const pattern = options.promptFilenamePattern ?? "**/*.prompt.{ts,js}";
  const prompts = await discoverPrompts(targetDir, pattern);

  if (!options.aiConfig) {
    throw new Error("AI config is required in nudge.config.json");
  }

  const existingPrompts = loadExistingPrompts(outputPath);

  if (Object.keys(existingPrompts).length === 0) {
    throw new Error("No generated prompts found. Run 'nudge generate' first.");
  }

  // Filter to prompts that have tests
  const promptsWithTests = prompts.filter(
    (p) => p.state.tests && p.state.tests.length > 0,
  );

  if (promptsWithTests.length === 0) {
    console.log("No prompts with tests found.");
    console.log(
      '\nAdd tests to your prompts using .test(input, assertion):\n\n  prompt("example", (p) =>\n    p\n      .persona("assistant")\n      .test("Hello", (output) => output.length > 0)\n      .test("Summarize this", "should be concise")\n  )',
    );
    return [];
  }

  console.log(
    `Evaluating ${promptsWithTests.length} prompt(s) with tests...\n`,
  );

  const evaluations: VariantEvaluation[] = [];

  for (const prompt of promptsWithTests) {
    const existing = existingPrompts[prompt.id];
    if (!existing) {
      console.log(`  ⚠ "${prompt.id}" not found in generated file, skipping`);
      continue;
    }

    const tests = prompt.state.tests as PromptTest[];

    for (const [variantName, text] of Object.entries(existing.variants)) {
      const evaluation = await evaluateVariant(
        prompt.id,
        variantName,
        text as string,
        tests,
        options.aiConfig,
        options.judge ?? false,
      );
      evaluations.push(evaluation);

      console.log(formatVariantEvaluation(evaluation, options.verbose ?? false));
    }
  }

  if (evaluations.length > 0) {
    console.log(formatEvaluationSummary(evaluations));
  }

  return evaluations;
}

export {
  discoverPrompts,
  evaluate,
  generate,
  improve,
  type DiscoveredPrompt,
  type ImprovementResult,
  type ImproveOptions,
  type VariantEvaluation,
};
