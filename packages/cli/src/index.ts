import type { BaseStep } from "@nudge-ai/core/internal";
import "dotenv/config";
import * as fs from "fs";
import { processPrompt, type AIConfig } from "./ai.js";
import { hashState, loadExistingPrompts } from "./cache.js";
import { discoverPrompts, type DiscoveredPrompt } from "./discover.js";

export type GenerateOptions = {
  promptFilenamePattern?: string;
  aiConfig?: AIConfig;
  noCache?: boolean;
};

function escapeForTemplateLiteral(text: string): string {
  return text
    .replace(/\\/g, "\\\\")
    .replace(/`/g, "\\`")
    .replace(/\$\{/g, "\\${");
}

function extractVariables(variants: Record<string, string>): string[] {
  const allVars = new Set<string>();
  for (const text of Object.values(variants)) {
    for (const match of text.matchAll(/\{\{(?![#\/])(\w+)\}\}/g)) {
      allVars.add(match[1]);
    }
  }
  return [...allVars];
}

async function generate(
  targetDir: string,
  outputPath: string,
  options: GenerateOptions = {},
) {
  const pattern = options.promptFilenamePattern ?? "**/*.prompt.{ts,js}";
  const prompts = await discoverPrompts(targetDir, pattern);

  if (!options.aiConfig) {
    throw new Error("AI config is required in nudge.config.json");
  }

  const existingPrompts = loadExistingPrompts(outputPath);

  console.log(`Processing ${prompts.length} prompt(s)...`);

  const results = await Promise.all(
    prompts.map(async (prompt) => {
      const hash = hashState(prompt.state);
      const existing = existingPrompts[prompt.id];

      let variants: Record<string, string>;

      if (!options.noCache && existing && existing.hash === hash) {
        console.log(`  ✓ "${prompt.id}" unchanged (cached)`);
        variants = existing.variants as Record<string, string>;
      } else {
        const definedVariants = prompt.state.variants ?? [];

        if (definedVariants.length === 0) {
          // No variants defined - generate single "default" prompt
          console.log(`  → "${prompt.id}" processing with AI...`);
          const text = await processPrompt(
            prompt.state.steps,
            options.aiConfig!,
          );
          variants = { default: text };
        } else {
          // Generate one prompt per variant (base steps + variant steps)
          console.log(
            `  → "${prompt.id}" generating ${definedVariants.length} variant(s)...`,
          );
          const variantEntries = await Promise.all(
            definedVariants.map(async (v) => {
              const combinedSteps: BaseStep[] = [
                ...prompt.state.steps,
                ...v.steps,
              ];
              const text = await processPrompt(
                combinedSteps,
                options.aiConfig!,
              );
              return [v.name, text] as const;
            }),
          );
          variants = Object.fromEntries(variantEntries);
        }
      }

      const variables = extractVariables(variants);

      const variantNames = Object.keys(variants).filter((k) => k !== "default");

      const variantEntries = Object.entries(variants)
        .map(([name, text]) => {
          const escaped = escapeForTemplateLiteral(text);
          return `      ${JSON.stringify(name)}: \`${escaped}\``;
        })
        .join(",\n");

      return {
        id: prompt.id,
        entry: `  ${JSON.stringify(prompt.id)}: {\n    variants: {\n${variantEntries},\n    },\n    hash: ${JSON.stringify(hash)},\n  }`,
        registry: `    ${JSON.stringify(prompt.id)}: true;`,
        variables:
          variables.length > 0
            ? `    ${JSON.stringify(prompt.id)}: ${variables.map((v) => JSON.stringify(v)).join(" | ")};`
            : null,
        variantNames:
          variantNames.length > 0
            ? `    ${JSON.stringify(prompt.id)}: ${variantNames.map((v) => JSON.stringify(v)).join(" | ")};`
            : null,
      };
    }),
  );

  const promptEntries = results.map((r) => r.entry);
  const registryEntries = results.map((r) => r.registry);
  const variableEntries = results
    .map((r) => r.variables)
    .filter((v): v is string => v !== null);
  const variantEntries = results
    .map((r) => r.variantNames)
    .filter((v): v is string => v !== null);

  const variablesInterface =
    variableEntries.length > 0
      ? `\n  interface PromptVariables {\n${variableEntries.join("\n")}\n  }`
      : "";

  const variantsInterface =
    variantEntries.length > 0
      ? `\n  interface PromptVariants {\n${variantEntries.join("\n")}\n  }`
      : "";

  const code = `// This file is auto-generated by @nudge-ai/cli. Do not edit manually.
import { registerPrompts } from "@nudge-ai/core";

declare module "@nudge-ai/core" {
  interface PromptRegistry {
${registryEntries.join("\n")}
  }${variablesInterface}${variantsInterface}
}

const prompts = {
${promptEntries.join(",\n")}
} as const;

registerPrompts(prompts);
`;

  // Write TypeScript file
  fs.writeFileSync(outputPath, code, "utf-8");
  console.log(`Generated ${outputPath} with ${prompts.length} prompt(s)`);
}

export { discoverPrompts, generate, type DiscoveredPrompt };
